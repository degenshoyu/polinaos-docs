---
title: "Core Modules"
---

## ğŸ§© Core Modules

The PolinaOS architecture is modular and extensible. You can adopt a single module or deploy the full loop â€” depending on your projectâ€™s needs. Each module is powered by specialized agents that collaborate to automate data collection, mission generation, impact assessment, and reward distribution.

---

### 1. ğŸ“Š Project Intelligence Layer

**Purpose**: Collect and analyze project context, trends, goals, and market positioning.

- **Data sources** include on-chain events, token metadata, and recent Twitter activity.
- The **Analysis Agent** is responsible for synthesizing this information into a real-time project profile â€” understanding your tokenâ€™s â€œvibe,â€ ideal shilling narratives, and evolving market momentum.
- This layer creates the intelligence foundation for task generation and contributor evaluation.

---

### 2. ğŸ¯ AI Mission Engine

**Purpose**: Automatically generate community tasks aligned with project objectives and current market signals.

- The **Creator Agent** leverages the intelligence layer to draft weekly quests: tweet prompts, meme formats, engagement drives, etc.
- Tasks are optimized for viral growth, meaningful action, and verifiable outcomes.
- An **Admin Interface** allows manual editing, review, or rejection before publishing to the public dashboard.
- Tasks support rich metadata including deadlines, hashtags, KPIs, and expected behavior.

---

### 3. ğŸ” Community Data Scanner

**Purpose**: Monitor, filter, and archive all community contributions across Twitter and the blockchain.

- The **Data Agent** operates a Puppeteer-based scanning infrastructure (via `ctScreener`) to track:
  - Who is tweeting (screen_name / wallet)
  - Whatâ€™s being shared (contract mentions, hashtags, memes)
  - When it happened (timestamp accuracy)
- It indexes everything via job ID, tweet ID, and token keyword.
- The agent works in tandem with `by-id`, `retweet`, and `user` APIs to build a verifiable activity graph for each contributor.

---

### 4. ğŸ§® Task Validation & Impact Scoring

**Purpose**: Evaluate contribution quality, detect sybil behavior, and assign reputational scores.

- The **Evaluator Agent** cross-references task data with scanner output.
- It uses content similarity checks, engagement metrics, and behavioral heuristics to:
  - Eliminate fake or duplicated submissions
  - Flag low-effort engagement (e.g., bot retweets)
  - Score based on reach, quality, timeliness, and originality
- Outputs include individual reputation scores and ranked contributor lists â€” per task or weekly.

---

### 5. ğŸ Reward Distribution Layer

**Purpose**: Automatically distribute tokens or points to contributors based on impact.

- The **Reward Agent** reads evaluation output and applies allocation rules.
  - Example: â€œTop 50 wallets by weekly score get 2% of allocation.â€
- It generates **Merkle claim proofs** and supports **Solana-based claim contracts**, with EVM support planned.
- Everything is auditable and trustless â€” no need for manual approval or centralized payout systems.

---

### ğŸ–¥ï¸ Admin & Community Dashboard

PolinaOS comes with a built-in Dashboard that serves both project teams and contributors.

- ğŸ§­ **Community Intelligence Dashboard**
  A real-time cockpit for project teams. Monitor tasks, contributor activity, Twitter spread, and on-chain actions â€” all in one place. Includes analytics on project performance, KOL Leaderboard, Project Leaderboard, and sentiment trends.

- ğŸ† **Mission Portal & Leaderboard**
  A public-facing portal for contributors. Claim rewards, track progress, and build on-chain reputation. Each projectâ€™s leaderboard highlights top performers and community champions.

This unified dashboard ensures transparency for contributors and provides teams with the intelligence needed to refine campaigns and scale impact.

---

Together, these modules â€” orchestrated by dedicated AI agents â€” allow any project to bootstrap and scale a contributor ecosystem with little to no manual oversight. Each component can run independently or as part of a unified mission-to-reward loop.
